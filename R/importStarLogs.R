#' @title Import STAR log files
#'
#' @description Imports \code{Log.final.out} files generated by STAR
#'
#' @details Imports one or more \code{Log.final.out} files as output by the aligner STAR
#' Values which are simple to calculate from the returned information are returned
#' as proportions intead of percentages.
#' Indel and substitution rates are left as character values showing percentages.
#'
#' @param path \code{character}. Vector of filenames
#'
#' @return A \code{data_frame}.
#' Column names are broadly similar to those in the supplied files,
#' but have been modified for easier handling under R naming conventions.
#'
#' In addition, the columns \code{Mapping_Duration} and the overall \code{Mapping_Rate}
#' are returned
#'
#' @export
importStarLogs <- function(path){

  path <- unique(path) # Remove any  duplicates
  stopifnot(file.exists(path)) # Check they all exist
  # Load them all
  data <- suppressWarnings(lapply(path, readr::read_delim,
                                  delim = "\t", col_names = c("Category", "Value"),
                                  col_types = "cc", trim_ws = TRUE) )
  names(data) <- basename(path)

  # Define a quick check
  isValidStarLog <- function(x){
    nLines <- length(x)
    if (!grepl("Started job on", x$Category[1])) return(FALSE)
    if (!grepl("UNIQUE READS:", x$Category[7])) return(FALSE)
    if (!grepl("MULTI-MAPPING READS:", x$Category[22])) return(FALSE)
    if (!grepl("UNMAPPED READS:", x$Category[27])) return(FALSE)
    TRUE
  }
  validLogs <- vapply(data, isValidStarLog, logical(1))
  if (any(!validLogs)) {
    stop(paste("Incorrect file structure for:", names(validLogs)[!validLogs], collapse = "\n"))
  }

  df <- lapply(names(data), function(x){
    dplyr::mutate(data[[x]], Filename = x)
  })
  df <- dplyr::bind_rows(df)
  df <- df[!is.na(df$Value),]

  # Tidy up the whitespace & pipe symbol
  df$Category <- stringr::str_replace(df$Category, "\\|", "")
  df$Category <- stringr::str_trim(df$Category)

  # Remove redundant information
  df$Category <- gsub("(Number of | per base| %)", "", df$Category)
  df$Category <- gsub("\\% of reads", "Percent", df$Category)
  df$Category <- gsub("(:|,)", "",  df$Category)

  # Customise some fields
  df$Category <- gsub("(Mapping speed).+", "\\1", df$Category)
  # df$Category <- gsub("input reads", "Total reads", df$Category)
  df$Category <- gsub("Average mapped length", "Uniquely mapped average length", df$Category)
  df$Category[!grepl("splices", df$Category)] <- stringr::str_to_title(df$Category[!grepl("splices", df$Category)])
  df$Category <- gsub("splices", "Splices", df$Category)
  df$Category <- gsub(" ", "_", df$Category)

  # Cast into the final structure
  colOrder <- unique(df$Category)
  df <- reshape2::dcast(df, Filename~Category, value.var = "Value")
  df <- df[, c("Filename", colOrder)]

  # Set some fields to more correct formats
  timeCols <- grep("On$", names(df))
  df[timeCols] <- lapply(df[timeCols], lubridate::parse_date_time, orders = "b! d! HMS")
  df$Mapping_Speed <- as.double(df$Mapping_Speed)
  df$Input_Reads <- as.integer(df$Input_Reads)
  df <- dplyr::rename(df, Average_Read_Length = Average_Input_Read_Length)
  df$Average_Read_Length <- as.integer(df$Average_Read_Length)

  # Tidy up the unique mappings
  df <- dplyr::rename(df,
                      Uniquely_Mapped_Proportion = Uniquely_Mapped_Reads,
                      Uniquely_Mapped_Reads = Uniquely_Mapped_Reads_Number)
  df$Uniquely_Mapped_Reads <- as.integer(df$Uniquely_Mapped_Reads)
  df$Uniquely_Mapped_Proportion <- with(df, Uniquely_Mapped_Reads / Input_Reads)
  df$Uniquely_Mapped_Average_Length <- as.double(df$Uniquely_Mapped_Average_Length)

  # The splice information is all integer values
  splCols <- grep("Splices", names(df))
  df[splCols] <- lapply(df[splCols], as.integer)

  # Leave the rates as percentages for Indels...
  df$Deletion_Average_Length <- as.double(df$Deletion_Average_Length)
  df$Insertion_Average_Length <- as.double(df$Insertion_Average_Length)

  # Tidy up the multi mapped reads
  df <- dplyr::rename(df,
                      Multi_Mapped_Reads = Reads_Mapped_To_Multiple_Loci,
                      Multi_Mapped_Proportion = Percent_Mapped_To_Multiple_Loci)
  df$Multi_Mapped_Reads <- as.integer(df$Multi_Mapped_Reads)
  df$Multi_Mapped_Proportion <- with(df, Multi_Mapped_Reads / Input_Reads)

  # And the reads mapped too many times
  df <- dplyr::rename(df,
                      Too_Many_Mapped_Reads = Reads_Mapped_To_Too_Many_Loci,
                      Too_Many_Mapped_Proportion = Percent_Mapped_To_Too_Many_Loci)
  df$Too_Many_Mapped_Reads <- as.integer(df$Too_Many_Mapped_Reads)
  df$Too_Many_Mapped_Proportion <- with(df, Too_Many_Mapped_Reads / Input_Reads)

  # And the unmapped reads
  names(df) <- gsub("Percent_(Unmapped.+)", "\\1_Proportion", names(df))
  unmapCols <- grep("Unmapped", names(df))
  df[unmapCols] <- lapply(df[unmapCols], function(x){
    as.numeric(gsub("%", "", x)) / 100
  })

  # Add Useful Information
  df$Mapping_Duration <- with(df, Finished_On - Started_Mapping_On)
  df$Mapping_Rate <- with(df, (Uniquely_Mapped_Reads + Multi_Mapped_Reads) / Input_Reads)

  # Reorder the columns to place these in sensible positions
  df <- dplyr::select(df, Filename,
                      dplyr::ends_with("On", ignore.case = FALSE),
                      dplyr::starts_with("Mapping"),
                      Input_Reads, Average_Read_Length, dplyr::everything())

  # Return as a tibble
  tibble::as_tibble(df)

}
